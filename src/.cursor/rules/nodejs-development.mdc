---
description: Node.js/Express development patterns for main application (RSS crawling, readability analysis, web dashboard)
globs: ["src/**/*.js", "src/**/*.json", "src/**/*.env"]
alwaysApply: false
---

# Node.js Development Rules - Modern Standards

## Code Quality Standards - ENFORCE THESE PATTERNS

### ES6+ Requirements
```javascript
// ✅ ALWAYS use const/let - NEVER var
const client = new MongoClient(connectionString);
let processedCount = 0;

// ✅ Use arrow functions for callbacks
const articles = await collection.find({}).toArray();
const processed = articles.map(article => processArticle(article));

// ✅ Use template literals for strings
const message = `Processing ${count} articles from ${source}`;
console.log(`Article processed: ${article.title}`);

// ✅ Use destructuring assignment
const { title, url, content } = article;
const { Flesch, Smog, GunningFog } = readabilityScores;
```

### Async/Await Patterns - MANDATORY
```javascript
// ✅ ALWAYS use async/await instead of .then()
async function scanFeeds() {
    try {
        await connection;
        const db = client.db('readability-database');
        const urlCollection = db.collection('urls');
        
        const urlList = await urlCollection.find({}).toArray();
        
        for (const urlDoc of urlList) {
            await processFeed(urlDoc.url);
        }
    } catch (error) {
        console.error('Error scanning feeds:', error);
        throw error;
    }
}

// ✅ Proper error handling with try/catch
async function parseAndSaveResponse(url) {
    try {
        const response = await fetch(`http://readability:3000`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ url })
        });
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        await saveArticleData(data);
        
    } catch (error) {
        console.error(`Failed to process article ${url}:`, error);
        // Don't rethrow unless necessary - log and continue
    }
}
```

## Express Patterns - Modern Structure

### Route Organization
```javascript
// ✅ Use Router for modular route organization
const express = require('express');
const router = express.Router();

// ✅ Async route handlers
router.get('/endpoint', async (req, res) => {
    try {
        const result = await someAsyncOperation();
        res.json({ success: true, data: result });
    } catch (error) {
        console.error('Route error:', error);
        res.status(500).json({ 
            success: false, 
            error: 'Internal server error' 
        });
    }
});

// ✅ Input validation and sanitization
router.post('/add-url', async (req, res) => {
    const { url } = req.query;
    
    if (!url || !isValidUrl(url)) {
        return res.status(400).json({ 
            success: false, 
            error: 'Valid URL required' 
        });
    }
    
    try {
        await addRssUrl(url);
        res.json({ success: true, message: 'URL added successfully' });
    } catch (error) {
        console.error('Failed to add URL:', error);
        res.status(500).json({ success: false, error: 'Failed to add URL' });
    }
});

module.exports = router;
```

### Database Operations - MODERN ASYNC PATTERNS
```javascript
// ✅ ALWAYS use async/await for database operations
async function saveArticleData(articleData) {
    try {
        await connection;
        const db = client.db('readability-database');
        const collection = db.collection('documents');
        
        // ✅ UPSERT pattern with proper error handling
        const result = await collection.replaceOne(
            { url: articleData.url }, 
            articleData, 
            { upsert: true }
        );
        
        console.log(`Article ${result.upsertedId ? 'inserted' : 'updated'}: ${articleData.url}`);
        return result;
        
    } catch (error) {
        console.error('Database operation failed:', error);
        throw new Error(`Failed to save article: ${error.message}`);
    }
}

// ✅ Use connection pooling and proper cleanup
const client = new MongoClient(connectionString, {
    maxPoolSize: 10,
    serverSelectionTimeoutMS: 5000,
    socketTimeoutMS: 45000,
});

// ✅ Graceful shutdown handling
process.on('SIGTERM', async () => {
    console.log('Shutting down gracefully...');
    await client.close();
    process.exit(0);
});
```

## Readability Analysis Pipeline - MODERN IMPLEMENTATION
```javascript
// ✅ Modular, testable functions
class ReadabilityAnalyzer {
    static cleanContent(rawContent) {
        if (!rawContent || typeof rawContent !== 'string') {
            throw new Error('Invalid content provided');
        }
        
        // Remove HTML, keep paragraphs, normalize whitespace
        const cleaned = striptags(rawContent, ['p'], ' ');
        return normalizeWhitespace(cleaned).trim();
    }
    
    static async calculateMetrics(cleanedContent) {
        if (!cleanedContent) {
            throw new Error('No content to analyze');
        }
        
        try {
            const stats = countable.count(cleanedContent);
            const syllableCount = syllable(cleanedContent);
            
            const metrics = {
                // Text statistics
                words: stats.words,
                sentences: stats.sentences,
                paragraphs: stats.paragraphs,
                characters: stats.characters,
                syllables: syllableCount,
                
                // Readability scores
                flesch: flesch(cleanedContent),
                fleschKincaid: fleschKincaid(cleanedContent),
                smog: smog(cleanedContent),
                daleChall: daleChall(cleanedContent),
                colemanLiau: colemanLiau(cleanedContent),
                gunningFog: gunningFog(cleanedContent),
                spache: spache(cleanedContent),
                automatedReadability: automatedReadability(cleanedContent)
            };
            
            // ✅ Validate all metrics are numbers
            Object.entries(metrics).forEach(([key, value]) => {
                if (typeof value !== 'number' || isNaN(value)) {
                    console.warn(`Invalid metric ${key}: ${value}`);
                    metrics[key] = 0;
                }
            });
            
            return metrics;
            
        } catch (error) {
            console.error('Readability calculation failed:', error);
            throw new Error(`Readability analysis failed: ${error.message}`);
        }
    }
    
    static async processArticle(articleUrl, rawContent) {
        try {
            const cleanedContent = this.cleanContent(rawContent);
            const metrics = await this.calculateMetrics(cleanedContent);
            
            const articleData = {
                url: articleUrl,
                content: rawContent,
                'Cleaned Data': cleanedContent,
                'Host': new URL(articleUrl).hostname,
                'publication date': new Date(),
                date: new Date(),
                ...metrics
            };
            
            return articleData;
            
        } catch (error) {
            console.error(`Failed to process article ${articleUrl}:`, error);
            throw error;
        }
    }
}

// ✅ Usage with proper error handling
async function parseAndSaveResponse(url) {
    try {
        const response = await fetch('http://readability:3000', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ url }),
            timeout: 30000 // 30 second timeout
        });
        
        if (!response.ok) {
            throw new Error(`Readability service error: ${response.status}`);
        }
        
        const { content } = await response.json();
        const articleData = await ReadabilityAnalyzer.processArticle(url, content);
        
        await saveArticleData(articleData);
        console.log(`Successfully processed: ${url}`);
        
    } catch (error) {
        console.error(`Processing failed for ${url}:`, error.message);
        // Continue processing other articles
    }
}
```

## RSS Processing Workflow - MODERN ASYNC IMPLEMENTATION
```javascript
// ✅ Main functions with proper error handling and logging
class RSSProcessor {
    static async startCron() {
        if (!cron.validate(config.interval)) {
            throw new Error(`Invalid cron expression: ${config.interval}`);
        }
        
        console.log(`Starting RSS crawler with schedule: ${config.interval}`);
        
        const task = cron.schedule(config.interval, async () => {
            console.log('Starting scheduled RSS scan...');
            try {
                await this.scanFeeds();
                console.log('RSS scan completed successfully');
            } catch (error) {
                console.error('RSS scan failed:', error);
            }
        });
        
        return task;
    }
    
    static async scanFeeds() {
        try {
            await connection;
            const db = client.db('readability-database');
            const urlCollection = db.collection('urls');
            
            const urlList = await urlCollection.find({}).toArray();
            console.log(`Monitoring ${urlList.length} RSS feeds`);
            
            // ✅ Process feeds with concurrency control
            const batchSize = 3;
            for (let i = 0; i < urlList.length; i += batchSize) {
                const batch = urlList.slice(i, i + batchSize);
                await Promise.allSettled(
                    batch.map(urlDoc => this.processSingleFeed(urlDoc))
                );
                
                // Brief pause between batches to avoid overwhelming services
                if (i + batchSize < urlList.length) {
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
            }
            
        } catch (error) {
            console.error('Failed to scan RSS feeds:', error);
            throw error;
        }
    }
    
    static async processSingleFeed(urlDoc) {
        try {
            console.log(`Processing RSS feed: ${urlDoc.name || urlDoc.url}`);
            
            const feed = await feedParser.parseURL(urlDoc.url);
            
            if (!feed.items || feed.items.length === 0) {
                console.warn(`No items found in feed: ${urlDoc.url}`);
                return;
            }
            
            // ✅ Process articles with rate limiting
            for (const item of feed.items.slice(0, 10)) { // Limit per feed
                if (item.link) {
                    await this.processArticle(item.link, urlDoc.url);
                    await new Promise(resolve => setTimeout(resolve, 500)); // Rate limit
                }
            }
            
        } catch (error) {
            console.error(`Failed to process feed ${urlDoc.url}:`, error.message);
        }
    }
    
    static async processArticle(articleUrl, originUrl) {
        try {
            validateUrl(articleUrl);
            
            // Check if article already exists
            await connection;
            const db = client.db('readability-database');
            const collection = db.collection('documents');
            
            const existing = await collection.findOne({ url: articleUrl });
            if (existing) {
                console.log(`Article already processed: ${articleUrl}`);
                return;
            }
            
            await parseAndSaveResponse(articleUrl, originUrl);
            
        } catch (error) {
            console.error(`Failed to process article ${articleUrl}:`, error.message);
        }
    }
}

// ✅ Content extraction with proper timeout and error handling
async function parseAndSaveResponse(articleUrl, originUrl) {
    try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 30000);
        
        const response = await fetch(config.readabilityServiceUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ url: articleUrl }),
            signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        
        if (!data.content) {
            throw new Error('No content extracted from article');
        }
        
        const articleData = await ReadabilityAnalyzer.processArticle(articleUrl, data.content);
        articleData.origin = originUrl;
        
        await saveArticleData(articleData);
        console.log(`Successfully processed: ${articleUrl}`);
        
    } catch (error) {
        if (error.name === 'AbortError') {
            console.error(`Timeout processing article: ${articleUrl}`);
        } else {
            console.error(`Processing failed for ${articleUrl}:`, error.message);
        }
        throw error;
    }
}
```

## Environment & Configuration - SECURE PRACTICES
```javascript
// ✅ Environment validation and defaults
require('dotenv').config();

const config = {
    interval: process.env.INTERVAL || '0 12 * * *',
    mongoUrl: process.env.MONGO_URL || 'mongodb://readability-database:27017',
    readabilityServiceUrl: process.env.READABILITY_URL || 'http://readability:3000',
    port: parseInt(process.env.PORT, 10) || 8080,
    nodeEnv: process.env.NODE_ENV || 'development'
};

// ✅ Configuration validation
function validateConfig() {
    const required = ['interval', 'mongoUrl', 'readabilityServiceUrl'];
    
    for (const key of required) {
        if (!config[key]) {
            throw new Error(`Missing required configuration: ${key}`);
        }
    }
    
    // Validate cron expression
    if (!cron.validate(config.interval)) {
        throw new Error(`Invalid cron expression: ${config.interval}`);
    }
}

// ✅ Secure logging (don't log sensitive data)
function logConfig() {
    console.log('Application configuration:');
    console.log(`- Environment: ${config.nodeEnv}`);
    console.log(`- Port: ${config.port}`);
    console.log(`- Cron interval: ${config.interval}`);
    console.log(`- MongoDB: ${config.mongoUrl.replace(/\/\/.*@/, '//***@')}`);
}

try {
    validateConfig();
    logConfig();
} catch (error) {
    console.error('Configuration error:', error.message);
    process.exit(1);
}

module.exports = config;
```

## MANDATORY Coding Standards - ENFORCE THESE

### Code Quality Requirements
1. **✅ ALWAYS use const/let** - NEVER use var
2. **✅ ALWAYS use async/await** - NEVER use .then().catch() chains
3. **✅ ALWAYS validate inputs** - Check types, ranges, and required fields
4. **✅ ALWAYS use try/catch** - Proper error handling for all async operations
5. **✅ ALWAYS use template literals** - `${variable}` instead of string concatenation
6. **✅ ALWAYS use arrow functions** - For callbacks and short functions
7. **✅ ALWAYS use destructuring** - Extract properties cleanly

### Database & Architecture Rules
1. **✅ ALWAYS use upsert pattern** - Prevent duplicate articles
2. **✅ ALWAYS await connection** - Before any database operations
3. **✅ ALWAYS validate data** - Before storing in database
4. **✅ ALWAYS use connection pooling** - Configure MongoDB client properly
5. **✅ ALWAYS implement graceful shutdown** - Clean up resources

### Error Handling Standards
```javascript
// ✅ REQUIRED error handling pattern
try {
    const result = await riskyOperation();
    return result;
} catch (error) {
    // Log with context
    console.error('Operation failed:', {
        operation: 'riskyOperation',
        error: error.message,
        stack: error.stack,
        timestamp: new Date().toISOString()
    });
    
    // Don't expose internal errors to clients
    throw new Error('Operation failed');
}
```

### Input Validation Standards
```javascript
// ✅ REQUIRED validation pattern
function validateUrl(url) {
    if (!url || typeof url !== 'string') {
        throw new Error('URL must be a non-empty string');
    }
    
    try {
        new URL(url);
        return true;
    } catch {
        throw new Error('Invalid URL format');
    }
}

// ✅ Use before any processing
app.post('/add-url', async (req, res) => {
    try {
        const { url } = req.body;
        validateUrl(url);
        
        const result = await addRssUrl(url);
        res.json({ success: true, data: result });
        
    } catch (error) {
        console.error('Add URL failed:', error);
        res.status(400).json({ 
            success: false, 
            error: error.message 
        });
    }
});
```

## Adding New Features - MODERN PATTERNS

### New API Endpoints
```javascript
// ✅ Use Express Router with modern async patterns
const router = express.Router();

// ✅ Modern endpoint pattern with validation and error handling
router.get('/new-endpoint', [
    // Input validation middleware
    (req, res, next) => {
        const { param1, param2 } = req.query;
        
        if (!param1 || typeof param1 !== 'string') {
            return res.status(400).json({
                success: false,
                error: 'param1 is required and must be a string'
            });
        }
        
        next();
    }
], async (req, res) => {
    try {
        const { param1, param2 } = req.query;
        
        await connection;
        const db = client.db('readability-database');
        const collection = db.collection('documents');
        
        const results = await collection.find({ 
            field: param1,
            ...(param2 && { otherField: param2 })
        }).toArray();
        
        res.json({
            success: true,
            data: results,
            count: results.length
        });
        
    } catch (error) {
        console.error('API endpoint error:', {
            endpoint: '/new-endpoint',
            error: error.message,
            params: req.query,
            timestamp: new Date().toISOString()
        });
        
        res.status(500).json({
            success: false,
            error: 'Internal server error'
        });
    }
});

// ✅ RESTful endpoint patterns
router.post('/articles', async (req, res) => {
    try {
        const articleData = req.body;
        
        // Validate input
        if (!articleData.url || !articleData.title) {
            return res.status(400).json({
                success: false,
                error: 'URL and title are required'
            });
        }
        
        const result = await saveArticleData(articleData);
        
        res.status(201).json({
            success: true,
            data: result,
            message: 'Article created successfully'
        });
        
    } catch (error) {
        console.error('Create article error:', error);
        res.status(500).json({
            success: false,
            error: 'Failed to create article'
        });
    }
});

module.exports = router;
```

### Adding New Readability Metrics
```javascript
// ✅ Extend ReadabilityAnalyzer class with new metrics
class ReadabilityAnalyzer {
    // ... existing methods
    
    static async calculateAdvancedMetrics(cleanedContent, basicStats) {
        try {
            const { words, sentences, syllables } = basicStats;
            
            const advancedMetrics = {
                // ✅ Add new metrics with validation
                newComplexityIndex: this.calculateNewComplexity({
                    sentences,
                    words,
                    syllables
                }),
                
                sentenceVariability: this.calculateSentenceVariability(cleanedContent),
                
                vocabularyDiversity: this.calculateVocabularyDiversity(cleanedContent)
            };
            
            // ✅ Validate all new metrics
            Object.entries(advancedMetrics).forEach(([key, value]) => {
                if (typeof value !== 'number' || isNaN(value)) {
                    console.warn(`Invalid advanced metric ${key}: ${value}`);
                    advancedMetrics[key] = 0;
                }
            });
            
            return advancedMetrics;
            
        } catch (error) {
            console.error('Advanced metrics calculation failed:', error);
            return {};
        }
    }
    
    static calculateNewComplexity({ sentences, words, syllables }) {
        if (!sentences || !words || !syllables) return 0;
        
        // ✅ Implement new metric with proper validation
        const avgWordsPerSentence = words / sentences;
        const avgSyllablesPerWord = syllables / words;
        
        return Math.round((avgWordsPerSentence * avgSyllablesPerWord) * 100) / 100;
    }
    
    static calculateSentenceVariability(content) {
        if (!content) return 0;
        
        const sentences = content.split(/[.!?]+/).filter(s => s.trim().length > 0);
        const lengths = sentences.map(s => s.trim().split(/\s+/).length);
        
        if (lengths.length < 2) return 0;
        
        const mean = lengths.reduce((sum, len) => sum + len, 0) / lengths.length;
        const variance = lengths.reduce((sum, len) => sum + Math.pow(len - mean, 2), 0) / lengths.length;
        
        return Math.round(Math.sqrt(variance) * 100) / 100;
    }
    
    static calculateVocabularyDiversity(content) {
        if (!content) return 0;
        
        const words = content.toLowerCase()
            .replace(/[^a-z\s]/g, '')
            .split(/\s+/)
            .filter(word => word.length > 2);
            
        if (words.length === 0) return 0;
        
        const uniqueWords = new Set(words);
        return Math.round((uniqueWords.size / words.length) * 10000) / 100; // Percentage
    }
    
    // ✅ Updated main calculation method
    static async calculateMetrics(cleanedContent) {
        if (!cleanedContent) {
            throw new Error('No content to analyze');
        }
        
        try {
            const stats = countable.count(cleanedContent);
            const syllableCount = syllable(cleanedContent);
            
            const basicMetrics = {
                words: stats.words,
                sentences: stats.sentences,
                paragraphs: stats.paragraphs,
                characters: stats.characters,
                syllables: syllableCount
            };
            
            const readabilityScores = {
                flesch: flesch(cleanedContent),
                fleschKincaid: fleschKincaid(cleanedContent),
                smog: smog(cleanedContent),
                daleChall: daleChall(cleanedContent),
                colemanLiau: colemanLiau(cleanedContent),
                gunningFog: gunningFog(cleanedContent),
                spache: spache(cleanedContent),
                automatedReadability: automatedReadability(cleanedContent)
            };
            
            // ✅ Add advanced metrics
            const advancedMetrics = await this.calculateAdvancedMetrics(cleanedContent, basicMetrics);
            
            const allMetrics = {
                ...basicMetrics,
                ...readabilityScores,
                ...advancedMetrics
            };
            
            // ✅ Validate all metrics
            Object.entries(allMetrics).forEach(([key, value]) => {
                if (typeof value !== 'number' || isNaN(value)) {
                    console.warn(`Invalid metric ${key}: ${value}`);
                    allMetrics[key] = 0;
                }
            });
            
            return allMetrics;
            
        } catch (error) {
            console.error('Metrics calculation failed:', error);
            throw new Error(`Readability analysis failed: ${error.message}`);
        }
    }
}
```

### Database Aggregations - OPTIMIZED PATTERNS
```javascript
// ✅ Performance-optimized aggregation patterns
class DatabaseQueries {
    static async getDailyStats(startDate, endDate) {
        try {
            await connection;
            const db = client.db('readability-database');
            const collection = db.collection('documents');
            
            const pipeline = [
                // ✅ Always filter first for performance
                {
                    $match: {
                        'publication date': {
                            $gte: new Date(startDate),
                            $lte: new Date(endDate)
                        },
                        'Flesch': { $exists: true, $ne: null }
                    }
                },
                
                // ✅ Group by relevant fields
                {
                    $group: {
                        _id: '$Host',
                        avgFlesch: { $avg: '$Flesch' },
                        avgSmog: { $avg: '$Smog' },
                        avgGunningFog: { $avg: '$GunningFog' },
                        articleCount: { $sum: 1 },
                        latestArticle: { $max: '$publication date' }
                    }
                },
                
                // ✅ Join with metadata
                {
                    $lookup: {
                        from: 'urls',
                        localField: '_id',
                        foreignField: 'url',
                        as: 'sourceInfo'
                    }
                },
                
                // ✅ Clean up and sort
                {
                    $addFields: {
                        sourceName: { $arrayElemAt: ['$sourceInfo.name', 0] },
                        reliability: { $arrayElemAt: ['$sourceInfo.reliability', 0] }
                    }
                },
                
                { $sort: { avgFlesch: -1 } },
                { $limit: 100 } // Prevent excessive results
            ];
            
            const results = await collection.aggregate(pipeline, {
                allowDiskUse: true, // For large datasets
                maxTimeMS: 30000    // 30 second timeout
            }).toArray();
            
            return results;
            
        } catch (error) {
            console.error('Daily stats aggregation failed:', error);
            throw new Error(`Failed to get daily stats: ${error.message}`);
        }
    }
    
    static async getSourceAnalytics(sourceHost) {
        try {
            if (!sourceHost || typeof sourceHost !== 'string') {
                throw new Error('Source host is required');
            }
            
            await connection;
            const db = client.db('readability-database');
            const collection = db.collection('documents');
            
            const [stats, recentArticles] = await Promise.all([
                // Overall statistics
                collection.aggregate([
                    { $match: { Host: sourceHost } },
                    {
                        $group: {
                            _id: null,
                            totalArticles: { $sum: 1 },
                            avgReadability: { $avg: '$Flesch' },
                            avgComplexity: { $avg: '$GunningFog' },
                            dateRange: {
                                $push: {
                                    min: { $min: '$publication date' },
                                    max: { $max: '$publication date' }
                                }
                            }
                        }
                    }
                ]).toArray(),
                
                // Recent articles
                collection.find({ Host: sourceHost })
                    .sort({ 'publication date': -1 })
                    .limit(10)
                    .project({ title: 1, url: 1, Flesch: 1, 'publication date': 1 })
                    .toArray()
            ]);
            
            return {
                statistics: stats[0] || null,
                recentArticles
            };
            
        } catch (error) {
            console.error(`Source analytics failed for ${sourceHost}:`, error);
            throw error;
        }
    }
}
```

## Dependencies & Libraries - MODERN STANDARDS

### Core Dependencies
```javascript
// ✅ Web framework with security middleware
const express = require('express');
const helmet = require('helmet');        // Security headers
const rateLimit = require('express-rate-limit'); // Rate limiting
const compression = require('compression'); // Response compression

// ✅ Database with proper configuration
const { MongoClient } = require('mongodb');

// ✅ RSS and content processing
const Parser = require('rss-parser');
const fetch = require('node-fetch');
const striptags = require('striptags');
const { htmlToText } = require('html-to-text');

// ✅ Readability analysis
const flesch = require('flesch');
const smog = require('smog-formula');
const gunningFog = require('gunning-fog');
const countable = require('countable');
const syllable = require('syllable');

// ✅ Task scheduling and utilities
const cron = require('node-cron');
const dotenv = require('dotenv');
```

### Security & Performance Setup
```javascript
// ✅ REQUIRED security middleware
app.use(helmet({
    contentSecurityPolicy: {
        directives: {
            defaultSrc: ["'self'"],
            scriptSrc: ["'self'", "'unsafe-inline'"],
            styleSrc: ["'self'", "'unsafe-inline'"],
            imgSrc: ["'self'", "data:", "https:"]
        }
    },
    hsts: {
        maxAge: 31536000,
        includeSubDomains: true
    }
}));

// ✅ Rate limiting
const limiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 100, // Limit each IP to 100 requests per windowMs
    message: 'Too many requests from this IP',
    standardHeaders: true,
    legacyHeaders: false
});
app.use('/api/', limiter);

// ✅ Response compression
app.use(compression());

// ✅ Request parsing with limits
app.use(express.json({ limit: '1mb' }));
app.use(express.urlencoded({ extended: true, limit: '1mb' }));

// ✅ Request logging middleware
app.use((req, res, next) => {
    console.log(`${new Date().toISOString()} - ${req.method} ${req.path}`);
    next();
});
```

### Environment Management
```javascript
// ✅ Environment-specific configurations
const environments = {
    development: {
        logLevel: 'debug',
        mongoOptions: { serverSelectionTimeoutMS: 5000 },
        fetchTimeout: 10000
    },
    production: {
        logLevel: 'info',
        mongoOptions: {
            maxPoolSize: 10,
            serverSelectionTimeoutMS: 5000,
            socketTimeoutMS: 45000
        },
        fetchTimeout: 30000
    }
};

const currentEnv = environments[config.nodeEnv] || environments.development;
```